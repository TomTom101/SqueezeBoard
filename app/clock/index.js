// Generated by CoffeeScript 1.8.0
angular.module('clock', ['common', 'ngAnimate']).controller('ClockController', [
  '$scope', '$interval', '$http', 'ClockService', 'ForecastFactory', function($scope, $interval, $http, ClockService, ForecastFactory) {
    var getForecast, getTomorrowData, skycons, tick, toggle_tommorrow_temp;
    document.addEventListener('deviceready', function() {
      return $scope.message = navigator.connection.type;
    }, false);
    steroids.statusBar.hide();
    $scope.temp = 0;
    $scope.toggle_tommorrow = false;
    skycons = new Skycons({
      "color": "grey"
    });
    skycons.play();
    tick = function() {
      $scope.time = ClockService.getTime();
      return $scope.date = ClockService.getDate();
    };
    getTomorrowData = function(response) {
      var find, tomorrow, tomorrow_data;
      tomorrow = moment().add(1, 'd').startOf('day').utc();
      find = find || {};
      steroids.logger.log("Tommorrow is " + (tomorrow.format()));
      find.time = parseInt(tomorrow.format('X'));
      tomorrow_data = _.where(response.daily.data, find);
      return tomorrow_data[0];
    };
    getForecast = function() {
      return ForecastFactory.currentForecast(function(error, response) {
        var tomorrow;
        if (error) {
          return steroids.logger.error(error);
        } else {
          tomorrow = getTomorrowData(response);
          $scope.temp_current = response.currently.apparentTemperature;
          $scope.temp_tomorrow_min = tomorrow.temperatureMin;
          $scope.temp_tomorrow_max = tomorrow.temperatureMax;
          skycons.set("current", response.currently.icon);
          return skycons.set("tomorrow", tomorrow.icon);
        }
      });
    };
    toggle_tommorrow_temp = function() {
      return $scope.toggle_tommorrow = !$scope.toggle_tommorrow;
    };
    $interval(toggle_tommorrow_temp, 1000 * 10);
    $interval(tick, 1000);
    $interval(getForecast, 1000 * 60 * 10);
    return getForecast();
  }
]).directive('animateOnChange', function($animate, $timeout) {
  return function(scope, elem, attr) {
    return scope.$watch(attr.animateOnChange, function(nv, ov) {
      if (nv !== ov) {
        return $animate.addClass(elem, 'change').then(function() {
          return $timeout(function() {
            return $animate.removeClass(elem, 'change');
          }, 2000);
        });
      }
    });
  };
});
